use std::fs;
use std::path::PathBuf;
use std::process::Command;

use starina::spec::AppSpec;
use starina::spec::EnvType;
use starina::spec::ExportItem;

pub fn autogen() {
    println!("cargo:rerun-if-changed=app.toml");

    let package_dir = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap());
    let app_toml_path = package_dir.join("app.toml");

    let app_toml = fs::read_to_string(app_toml_path).expect("failed to read app.toml");
    let app_spec: AppSpec = toml::from_str(&app_toml).expect("failed to parse app.toml");

    let mut env_str = String::new();
    let mut parsed_env_str = String::new();
    for (env_name, ty) in app_spec.env.iter() {
        let (env_ty, parsed_env_ty) = match ty {
            EnvType::Service {
                service: service_name,
            } => {
                let parsed_env_ty =
                    format!("ParsedEnvType::Service {{ service: \"{service_name}\" }}");
                ("Channel", parsed_env_ty)
            }
            EnvType::DeviceTree { matches } => {
                let mut matches_str = String::new();
                for m in matches {
                    matches_str.push_str(&format!("ParsedDeviceMatch::Compatible(\"{m}\")"));
                }

                let parsed_env_ty =
                    format!("ParsedEnvType::DeviceTree {{ matches: &[{matches_str}] }}");
                ("DeviceTree", parsed_env_ty)
            }
            EnvType::IoBusMap => {
                let parsed_env_ty = format!("ParsedEnvType::IoBusMap");
                ("HashMap<String, IoBus>", parsed_env_ty)
            }
        };

        env_str.push_str(&format!("    pub {env_name}: {env_ty},\n"));
        parsed_env_str.push_str(&format!(
            "ParsedEnvItem {{ name: \"{env_name}\", ty: {parsed_env_ty} }},\n",
        ));
    }

    let mut parsed_exports_str = String::new();
    for export in app_spec.exports.iter() {
        let export_str = match export {
            ExportItem::Service { service } => {
                format!("ParsedExportItem::Service {{ service: \"{service}\" }}")
            }
        };
        parsed_exports_str.push_str(&format!("{export_str},\n"));
    }

    let app_name = app_spec.name;
    let autogen_str = format!(
        r#"
// This file is auto-generated by starina_build_sdk.
// Do not edit this file directly.
#![allow(unused)]

use starina::prelude::*;
use starina::channel::Channel;
use starina::collections::HashMap;
use starina::device_tree::DeviceTree;
use starina::iobus::IoBus;
use starina::spec::ParsedAppSpec;
use starina::spec::ParsedEnvType;
use starina::spec::ParsedEnvItem;
use starina::spec::ParsedExportItem;
use starina::spec::ParsedDeviceMatch;
use starina::syscall::VsyscallPage;
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct Env {{
    pub startup_ch: Channel,
{env_str}
}}

pub const APP_SPEC: ParsedAppSpec = ParsedAppSpec {{
    name: "{app_name}",
    env: &[{parsed_env_str}],
    exports: &[{parsed_exports_str}],
    entrypoint,
}};

extern "C" fn entrypoint(vsyscall: *const VsyscallPage) -> ! {{
    starina::eventloop::app_loop::<Env, crate::State, crate::App>("{app_name}", vsyscall);
}}
"#
    );

    let autogen_path = package_dir.join("src").join("autogen.rs");
    fs::write(&autogen_path, autogen_str).expect("failed to write autogen.rs");
    Command::new("rustfmt")
        .arg(autogen_path)
        .status()
        .expect("failed to format autogen.rs");
}
