pub mod ftl_autogen2_generated {
    use ftl_api::types as ftl_types;

    use ftl_types::message::MessageSerialize;
    use ftl_types::message::MessageDeserialize;
    use ftl_types::message::MessageBuffer;
    use ftl_types::message::MessageInfo;
    use ftl_types::message::MovedHandle;

    pub mod protocols {
        use super::*;

        {% for protocol in protocols %}
        pub mod {{ protocol.name }} {
            use super::*;

            {% for m in protocol.messages %}
            #[repr(C)]
            {% if m.has_bytes_fields %}
            pub struct {{ m.name }}<'a> {
            {% else %}
            pub struct {{ m.name }} {
            {% endif %}
                {%- for f in m.fields %}
                    {% if not f.is_handle %}
                        pub {{ f.name }}: {{ f.builder_ty }},
                    {%- endif %}
                {%- endfor %}

                {%- for f in m.fields %}
                    {% if f.is_handle %}
                        pub {{ f.name }}: MovedHandle,
                    {% endif %}
                {%- endfor %}
            }

            #[repr(C)]
            struct Raw{{ m.name }} {
                {%- for f in m.fields %}
                    {% if not f.is_handle %}
                        pub {{ f.name }}: {{ f.raw_ty }},
                    {% endif %}
                {%- endfor %}
            }

            {% if m.has_bytes_fields %}
            impl<'a> MessageSerialize for {{ m.name }}<'a> {
            {% else %}
            impl MessageSerialize for {{ m.name }} {
            {% endif %}
                const MSGINFO: MessageInfo = MessageInfo::from_raw(
                    ({{ m.msgid }} << 14)
                    | ({{ m.num_handles }} << 12)
                    | ::core::mem::size_of::<Raw{{ m.name }}>() as isize,
                );

                fn serialize(self, buffer: &mut MessageBuffer) {
                    // TODO: Make this a compile-time assertion.
                    debug_assert!(::core::mem::size_of::<{{ m.name }}>() < 1 << 12);

                    #[allow(unused)]
                    let dst = buffer as *mut _ as *mut Raw{{ m.name }};

                    {% for f in m.fields %}
                        {% if f.is_bytes %}
                            unsafe {
                                (*dst).{{ f.name }}.copy_from_slice(&self.{{ f.name }});
                            }
                        {%- elif not f.is_handle %}
                            unsafe {
                                core::ptr::write(&mut (*dst).{{ f.name }}, self.{{ f.name }});
                            }
                        {%- endif %}
                    {%- endfor %}

                    // FIXME: Support multiple handles.
                    debug_assert!(MessageInfo::from_raw({{ m.name }}::MSGINFO.as_raw()).num_handles() <= 1);

                    {%- for f in m.fields %}
                        {% if f.is_handle %}
                            buffer.handles[0] = self.{{ f.name }}.0;
                        {%- endif %}
                    {%- endfor %}

                    // Don't call destructors on handles transferred to this buffer.
                    core::mem::forget(self);
                }
            }

            {% if m.has_bytes_fields %}
            impl<'m> MessageDeserialize for {{ m.name }}<'m> {
            {% else %}
            impl MessageDeserialize for {{ m.name }} {
            {% endif %}
                type Reader<'a> = {{ m.name }}Reader<'a>;

                fn deserialize<'a>(
                    buffer: &'a MessageBuffer,
                    msginfo: MessageInfo
                ) -> Option<{{ m.name }}Reader<'a>> {
                    if msginfo == Self::MSGINFO {
                        Some({{ m.name }}Reader {
                            buffer,
                            handles_taken: [false; {{ m.num_handles }}],
                        })
                    } else {
                        None
                    }
                }
            }

            pub struct {{ m.name }}Reader<'a> {
                #[allow(dead_code)]
                buffer: &'a MessageBuffer,
                #[allow(dead_code)]
                handles_taken: [bool; {{ m.num_handles }}],
            }

            impl<'a> {{ m.name }}Reader<'a> {
                #[allow(dead_code)]
                fn as_raw(&self, buffer: &'a MessageBuffer) -> &'a Raw{{ m.name }} {
                    unsafe { &*(buffer as *const _ as *const Raw{{ m.name }}) }
                }

                {% for f in m.fields %}
                    {% if f.is_handle %}
                        {% if generate_for_app and f.ty == "channel" %}
                            pub fn {{ f.name }}(&mut self) -> Option<::ftl_api::channel::Channel> {
                                let handle_index = 0; // FIXME: Support multiple handles.
                                let handle_id = self.buffer.handles[handle_index];

                                if self.handles_taken[handle_index] {
                                    return None;
                                }

                                self.handles_taken[handle_index] = true;

                                let owned = ::ftl_api::handle::OwnedHandle::from_raw(handle_id);
                                let ch = ::ftl_api::channel::Channel::from_handle(owned);
                                Some(ch)
                            }
                        {% endif %}

                        pub fn {{ f.name }}_raw(&self) -> ftl_types::handle::HandleId {
                            // FIXME: Support multiple handles.
                            self.buffer.handles[0]
                        }
                    {% else %}
                        pub fn {{ f.name }}(&self) -> {{ f.raw_ty }} {
                            let m = self.as_raw(self.buffer);
                            m.{{ f.name }}
                        }
                    {% endif %}
                {% endfor %}
            }
            {% endfor %}
        }
        {% endfor %}
    }

    pub enum Message<'a> {
        {%- for m in app.used_messages %}
        {{ m.camel_name }}({{ m.ty }}Reader<'a>),
        {%- endfor %}
    }

    impl<'a> ::core::fmt::Debug for Message<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
                {%- for m in app.used_messages %}
                Self::{{ m.camel_name }}(_) => write!(f, "{{ m.camel_name }}"),
                {%- endfor %}
            }
        }
    }

    impl<'b> MessageDeserialize for Message<'b> {
        type Reader<'a> = Message<'a>;

        fn deserialize<'a>(
            buffer: &'a MessageBuffer,
            msginfo: MessageInfo
        ) -> Option<Self::Reader<'a>> {
            match msginfo {
                {% for m in app.used_messages %}
                {{ m.ty }}::MSGINFO => {
                    use {{ m.ty }} as M;

                    let reader = M::deserialize(buffer, msginfo)?;
                    Some(Message::{{ m.camel_name }}(reader))
                },
                {% endfor %}
                _ => None,
            }
        }
    }
}
